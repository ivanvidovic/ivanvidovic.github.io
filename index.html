<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Brochure Preview</title>
    <style>
        /* Basic styling to make the canvas fill the entire screen */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            /* The background is now handled inside the 3D scene, 
               but we keep a fallback color here. */
            background-color: #5a6474; 
            color: #333;
        }
        canvas {
            display: block;
        }
        /* Style for the instruction overlay */
        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            text-align: center;
            z-index: 100;
            
            /* Glassmorphism Style */
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); /* For Safari compatibility */
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            
            color: white;
            font-size: 13px;
            letter-spacing: 0.5px;
            line-height: 1.5;
        }
        #info strong {
            font-weight: 600;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <div id="info">
        <strong>Click:</strong> Focus &nbsp;&nbsp;|&nbsp;&nbsp; <strong>LMB Drag:</strong> Rotate &nbsp;&nbsp;|&nbsp;&nbsp; <strong>Scroll:</strong> Zoom &nbsp;&nbsp;|&nbsp;&nbsp; <strong>Dbl-Click:</strong> Reset
    </div>

    <!-- Import Three.js library -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // Import necessary modules from Three.js
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // Import post-processing modules for Depth of Field effect
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        // We will create the background gradient using a custom shader on a plane.
        scene.background = new THREE.Color(0x5a6474); // Set a solid fallback color

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15); // Set initial camera position
        scene.add(camera); // Add camera to the scene so we can add lights to it

        // The renderer no longer needs to be transparent.
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- Gradient Background ---
        // We create a background plane with a custom shader material to draw the gradient.
        // This is more robust than using CSS when post-processing effects are active.
        const backgroundVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position.xy, 1.0, 1.0);
            }
        `;

        const backgroundFragmentShader = `
            uniform vec3 color1;
            uniform vec3 color2;
            varying vec2 vUv;
            
            void main() {
                // Calculate the distance from the center (0.5, 0.5)
                float d = distance(vUv, vec2(0.5, 0.5));
                // Mix the two colors based on the distance
                gl_FragColor = vec4(mix(color1, color2, smoothstep(0.0, 0.7, d)), 1.0);
            }
        `;
        
        const backgroundGeometry = new THREE.PlaneGeometry(2, 2);
        const backgroundMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color1: { value: new THREE.Color(0xb4b4b1) },
                color2: { value: new THREE.Color(0x5a6474) }
            },
            vertexShader: backgroundVertexShader,
            fragmentShader: backgroundFragmentShader,
            depthWrite: false
        });

        const backgroundMesh = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
        backgroundMesh.renderOrder = -1; // Ensure it's rendered first (in the background)
        scene.add(backgroundMesh);


        // --- Post-processing for Depth of Field ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bokehPass = new BokehPass(scene, camera, {
            focus: 1.0,
            aperture: 0, // Start with zero blur
            maxblur: 0.004, // Decreased by 50%
            width: window.innerWidth,
            height: window.innerHeight
        });
        composer.addPass(bokehPass);


        // --- Lighting ---
        // Add soft ambient light to illuminate the entire scene
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); 
        scene.add(ambientLight);

        // Add a directional light to create highlights and give the form more definition
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.575);
        directionalLight.position.set(5, 10, 7.5); // Position the light relative to the camera
        camera.add(directionalLight); // Add the light as a child of the camera

        // --- Brochure Trifold ---
        const planeWidth = 11;
        const planeHeight = 8.5;
        const panelWidth = planeWidth / 3;
        const brochureThickness = 0.005; // Decreased by 90%

        const textureLoader = new THREE.TextureLoader();
        
        // --- How to run this locally ---
        // To test with local files ('inside.jpg', 'outside.jpg'), you must run a simple
        // local web server. Browsers block loading local files for security reasons (CORS policy).
        // Details are in the comments of previous versions.

        const frontTexture = textureLoader.load('inside.jpg');
        const backTexture = textureLoader.load('outside.jpg');

        // Flip the entire back texture horizontally so we can map it correctly
        backTexture.wrapS = THREE.RepeatWrapping;
        backTexture.repeat.x = -1;

        const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
        frontTexture.anisotropy = maxAnisotropy;
        backTexture.anisotropy = maxAnisotropy;

        // Helper function to create a panel with correct textures
        function createPanel(frontUvOffset, backUvOffset) {
            const uvWidth = 1 / 3;
            const geometry = new THREE.BoxGeometry(panelWidth, planeHeight, brochureThickness);

            // Clone textures to allow for independent UV transformations per panel
            const frontTex = frontTexture.clone();
            frontTex.needsUpdate = true; // Important when cloning
            frontTex.repeat.set(uvWidth, 1);
            frontTex.offset.set(frontUvOffset, 0);

            const backTex = backTexture.clone();
            backTex.needsUpdate = true;
            backTex.repeat.set(uvWidth, 1);
            backTex.offset.set(backUvOffset, 0);

            const materials = [
                new THREE.MeshStandardMaterial({ color: 0xdddddd }), // right
                new THREE.MeshStandardMaterial({ color: 0xdddddd }), // left
                new THREE.MeshStandardMaterial({ color: 0xdddddd }), // top
                new THREE.MeshStandardMaterial({ color: 0xdddddd }), // bottom
                new THREE.MeshStandardMaterial({ map: frontTex }), // front
                new THREE.MeshStandardMaterial({ map: backTex }),  // back
            ];

            return new THREE.Mesh(geometry, materials);
        }

        // --- Assemble the Brochure ---
        // The brochure group is the main container for all panels.
        const brochure = new THREE.Group();
        scene.add(brochure);

        // The back of the right panel is the leftmost third of the original (unflipped) outside image.
        // After flipping, this corresponds to the rightmost third.
        const rightPanelMesh = createPanel(2 / 3, 2 / 3);
        const centerPanelMesh = createPanel(1 / 3, 1 / 3);
        // The back of the left panel is the rightmost third (the cover). After flipping, it's the leftmost third.
        const leftPanelMesh = createPanel(0, 0);

        // -- Center Panel --
        brochure.add(centerPanelMesh);

        // -- Left Panel --
        const leftPivot = new THREE.Group();
        leftPivot.position.x = -panelWidth / 2;
        leftPanelMesh.position.x = -panelWidth / 2;
        leftPivot.add(leftPanelMesh);
        brochure.add(leftPivot);

        // -- Right Panel --
        const rightPivot = new THREE.Group();
        rightPivot.position.x = panelWidth / 2;
        rightPanelMesh.position.x = panelWidth / 2;
        rightPivot.add(rightPanelMesh);
        brochure.add(rightPivot);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.enableZoom = false;

        // --- Animation & Interaction Variables ---
        const cameraDirection = new THREE.Vector3();
        const minFoldAngle = Math.PI / 16;
        const maxFoldAngle = Math.PI / 4;

        let targetDistance = camera.position.distanceTo(controls.target);
        const initialDistance = targetDistance;

        const initialCameraPosition = camera.position.clone();
        const initialControlsTarget = controls.target.clone();
        let isResetting = false;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetFocusPoint = new THREE.Vector3(0, 0, 0);
        const mouseDownPosition = new THREE.Vector2();
        let targetFocusDistance = initialDistance;


        // --- Event Listeners ---
        renderer.domElement.addEventListener('wheel', event => {
            event.preventDefault();
            isResetting = false;
            const zoomSpeed = 0.1;
            targetDistance += event.deltaY * zoomSpeed;
            targetDistance = THREE.MathUtils.clamp(targetDistance, controls.minDistance, controls.maxDistance);
            targetFocusDistance = targetDistance;
        });

        renderer.domElement.addEventListener('dblclick', () => {
            isResetting = true;
            targetDistance = initialDistance;
            targetFocusPoint.copy(initialControlsTarget);
            targetFocusDistance = initialDistance;
        });
        
        renderer.domElement.addEventListener('pointerdown', (event) => {
            mouseDownPosition.set(event.clientX, event.clientY);
        });

        renderer.domElement.addEventListener('pointerup', (event) => {
            const dragDistance = mouseDownPosition.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
            
            if (dragDistance < 5) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(brochure, true);

                if (intersects.length > 0) {
                    isResetting = false;
                    targetFocusPoint.copy(intersects[0].point);
                    targetFocusDistance = intersects[0].distance;
                }
            }
        });

        controls.addEventListener('start', () => {
            isResetting = false;
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (isResetting) {
                camera.position.lerp(initialCameraPosition, 0.08);
                controls.target.lerp(initialControlsTarget, 0.08);
                if (camera.position.distanceTo(initialCameraPosition) < 0.01) {
                    isResetting = false;
                    camera.position.copy(initialCameraPosition);
                    controls.target.copy(initialControlsTarget);
                }
            } else {
                controls.target.lerp(targetFocusPoint, 0.1);
            }

            const currentDistance = camera.position.distanceTo(controls.target);
            if (!isResetting) {
                const smoothedDistance = THREE.MathUtils.lerp(currentDistance, targetDistance, 0.1);
                const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                camera.position.copy(controls.target).addScaledVector(direction, smoothedDistance);
            }
            
            // --- Update Depth of Field ---
            const focusDist = THREE.MathUtils.lerp(bokehPass.uniforms['focus'].value, targetFocusDistance, 0.1);
            bokehPass.uniforms['focus'].value = focusDist;
            
            const apertureRange = 0.004; // Decreased by 50%
            let apertureValue = 0;
            if (focusDist < initialDistance) {
                const normalizedZoom = 1 - ((focusDist - controls.minDistance) / (initialDistance - controls.minDistance));
                apertureValue = THREE.MathUtils.clamp(normalizedZoom, 0, 1) * apertureRange;
            }
            bokehPass.uniforms['aperture'].value = apertureValue;


            // --- Flap Animation Logic ---
            camera.getWorldDirection(cameraDirection);
            const viewFactor = Math.max(0, -cameraDirection.z);
            const targetAngle = THREE.MathUtils.lerp(minFoldAngle, maxFoldAngle, viewFactor);
            leftPivot.rotation.y = THREE.MathUtils.lerp(leftPivot.rotation.y, targetAngle, 0.05);
            rightPivot.rotation.y = THREE.MathUtils.lerp(rightPivot.rotation.y, -targetAngle, 0.05);

            controls.update();
            composer.render();
        }

        // --- Handle Window Resizing ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        // Start the animation loop
        animate();
    </script>
</body>
</html>
